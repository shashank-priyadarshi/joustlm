package internal

import (
	"database/sql"
	"fmt"
	"testing"
	"time"

	"github.com/google/uuid"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
	"go.ssnk.in/joustlm/config"
	"go.ssnk.in/joustlm/logger"
	"go.ssnk.in/joustlm/schema/db"
)

type DaoTestSuite struct {
	suite.Suite
	dao  *Dao
	log  logger.Logger
	conf *config.Database
}

func (suite *DaoTestSuite) SetupTest() {
	suite.log = logger.New(logger.SetLevel(logger.Debug))
	// Use a shared database file for all tables to ensure migrations work across all operations
	dbFile := fmt.Sprintf("file:test_%d.db?mode=memory&cache=shared", time.Now().UnixNano())
	suite.conf = &config.Database{
		DSN: map[config.Tables]string{
			config.TableUsers:    dbFile,
			config.TableAnalyses: dbFile,
		},
	}
	suite.dao = NewDao(&suite.log, suite.conf)
	require.NotNil(suite.T(), suite.dao, "DAO should be created successfully")

	err := suite.dao.RunMigrations()
	require.NoError(suite.T(), err, "Migrations should run successfully")
}

func (suite *DaoTestSuite) TearDownTest() {
	if suite.dao != nil {
		suite.dao.Close()
	}
}

func (suite *DaoTestSuite) TestRunMigrations() {
	tests := []struct {
		name        string
		expectError bool
	}{
		{
			name:        "should run migrations successfully",
			expectError: false,
		},
	}

	for _, tt := range tests {
		suite.Run(tt.name, func() {
			// SetupTest already runs migrations, so we just verify they completed
			assert.NotNil(suite.T(), suite.dao, "DAO should be initialized")
		})
	}
}

func (suite *DaoTestSuite) TestCreateUser() {
	tests := []struct {
		name        string
		user        *db.User
		expectError bool
	}{
		{
			name: "should create user successfully",
			user: &db.User{
				ID:           uuid.New(),
				Username:     "testuser1",
				PasswordHash: "hashedpassword1",
				SessionID:    sql.NullString{String: "session123", Valid: true},
			},
			expectError: false,
		},
		{
			name: "should create user with empty session",
			user: &db.User{
				ID:           uuid.New(),
				Username:     "testuser2",
				PasswordHash: "hashedpassword2",
				SessionID:    sql.NullString{Valid: false},
			},
			expectError: false,
		},
	}

	for _, tt := range tests {
		suite.Run(tt.name, func() {
			err := suite.dao.CreateUser(tt.user)
			if tt.expectError {
				assert.Error(suite.T(), err, "Expected error but got none")
			} else {
				assert.NoError(suite.T(), err, "CreateUser should not return error")

				// Verify user was created
				createdUser, err := suite.dao.GetUserByUsername(tt.user.Username)
				require.NoError(suite.T(), err, "GetUserByUsername should not return error")
				require.NotNil(suite.T(), createdUser, "User should be found")
				assert.Equal(suite.T(), tt.user.Username, createdUser.Username, "Username should match")
				assert.Equal(suite.T(), tt.user.ID, createdUser.ID, "User ID should match")
			}
		})
	}
}

func (suite *DaoTestSuite) TestCreateAnalysis() {
	tests := []struct {
		name        string
		analysis    *db.Analysis
		expectError bool
	}{
		{
			name: "should create analysis successfully",
			analysis: &db.Analysis{
				ID:         uuid.New(),
				UserID:     uuid.New(),
				Text:       "This is a sample text for analysis. It contains multiple sentences and should be processed by the LLM to extract structured information.",
				Title:      "Sample Analysis",
				Summary:    "This is a sample summary generated by the LLM for testing purposes.",
				Topics:     []string{"technology", "analysis", "data"},
				Sentiment:  "neutral",
				Keywords:   []string{"sample", "analysis", "text"},
				Confidence: 0.85,
			},
			expectError: false,
		},
		{
			name: "should create analysis with different content",
			analysis: &db.Analysis{
				ID:         uuid.New(),
				UserID:     uuid.New(),
				Text:       "Artificial intelligence is transforming the way we work and live. Machine learning algorithms are becoming more sophisticated every day.",
				Title:      "AI Transformation",
				Summary:    "The text discusses the impact of artificial intelligence on society and work.",
				Topics:     []string{"artificial intelligence", "technology", "future"},
				Sentiment:  "positive",
				Keywords:   []string{"intelligence", "algorithms", "learning"},
				Confidence: 0.92,
			},
			expectError: false,
		},
	}

	for _, tt := range tests {
		suite.Run(tt.name, func() {
			err := suite.dao.CreateAnalysis(tt.analysis)
			if tt.expectError {
				assert.Error(suite.T(), err, "Expected error but got none")
			} else {
				assert.NoError(suite.T(), err, "CreateAnalysis should not return error")

				// Verify analysis was created
				createdAnalysis, err := suite.dao.GetAnalysisByID(tt.analysis.ID)
				require.NoError(suite.T(), err, "GetAnalysisByID should not return error")
				require.NotNil(suite.T(), createdAnalysis, "Analysis should be found")
				assert.Equal(suite.T(), tt.analysis.Text, createdAnalysis.Text, "Text should match")
				assert.Equal(suite.T(), tt.analysis.ID, createdAnalysis.ID, "Analysis ID should match")
				assert.Equal(suite.T(), tt.analysis.Title, createdAnalysis.Title, "Title should match")
				assert.Equal(suite.T(), tt.analysis.Summary, createdAnalysis.Summary, "Summary should match")
				assert.Equal(suite.T(), tt.analysis.Topics, createdAnalysis.Topics, "Topics should match")
				assert.Equal(suite.T(), tt.analysis.Sentiment, createdAnalysis.Sentiment, "Sentiment should match")
				assert.Equal(suite.T(), tt.analysis.Keywords, createdAnalysis.Keywords, "Keywords should match")
				assert.Equal(suite.T(), tt.analysis.Confidence, createdAnalysis.Confidence, "Confidence should match")
			}
		})
	}
}

func (suite *DaoTestSuite) TestGetAnalysisByID() {
	tests := []struct {
		name           string
		setupAnalysis  *db.Analysis
		analysisID     uuid.UUID
		expectError    bool
		expectFound    bool
	}{
		{
			name: "should retrieve existing analysis",
			setupAnalysis: &db.Analysis{
				ID:         uuid.New(),
				UserID:     uuid.New(),
				Text:       "This is a test analysis for retrieval testing.",
				Title:      "Test Analysis",
				Summary:    "This analysis is used for testing retrieval functionality.",
				Topics:     []string{"testing", "retrieval", "analysis"},
				Sentiment:  "neutral",
				Keywords:   []string{"test", "analysis", "retrieval"},
				Confidence: 0.75,
			},
			expectError: false,
			expectFound: true,
		},
		{
			name:        "should return nil for non-existing analysis",
			analysisID:  uuid.New(),
			expectError: false,
			expectFound: false,
		},
	}

	for _, tt := range tests {
		suite.Run(tt.name, func() {
			var analysisID uuid.UUID
			if tt.setupAnalysis != nil {
				// Create analysis first
				err := suite.dao.CreateAnalysis(tt.setupAnalysis)
				require.NoError(suite.T(), err, "Failed to create analysis for test")
				analysisID = tt.setupAnalysis.ID
			} else {
				analysisID = tt.analysisID
			}

			// Test GetAnalysisByID
			retrievedAnalysis, err := suite.dao.GetAnalysisByID(analysisID)
			if tt.expectError {
				assert.Error(suite.T(), err, "Expected error but got none")
			} else {
				assert.NoError(suite.T(), err, "GetAnalysisByID should not return error")
				if tt.expectFound {
					require.NotNil(suite.T(), retrievedAnalysis, "Analysis should be found")
					assert.Equal(suite.T(), analysisID, retrievedAnalysis.ID, "Analysis ID should match")
					if tt.setupAnalysis != nil {
						assert.Equal(suite.T(), tt.setupAnalysis.Text, retrievedAnalysis.Text, "Text should match")
						assert.Equal(suite.T(), tt.setupAnalysis.Title, retrievedAnalysis.Title, "Title should match")
						assert.Equal(suite.T(), tt.setupAnalysis.Summary, retrievedAnalysis.Summary, "Summary should match")
						assert.Equal(suite.T(), tt.setupAnalysis.Topics, retrievedAnalysis.Topics, "Topics should match")
						assert.Equal(suite.T(), tt.setupAnalysis.Sentiment, retrievedAnalysis.Sentiment, "Sentiment should match")
						assert.Equal(suite.T(), tt.setupAnalysis.Keywords, retrievedAnalysis.Keywords, "Keywords should match")
						assert.Equal(suite.T(), tt.setupAnalysis.Confidence, retrievedAnalysis.Confidence, "Confidence should match")
					}
				} else {
					assert.Nil(suite.T(), retrievedAnalysis, "Analysis should not be found")
				}
			}
		})
	}
}

func (suite *DaoTestSuite) TestGetUserByUsername() {
	tests := []struct {
		name        string
		setupUser   *db.User
		username    string
		expectError bool
		expectFound bool
	}{
		{
			name: "should retrieve existing user",
			setupUser: &db.User{
				ID:           uuid.New(),
				Username:     "testuser3",
				PasswordHash: "hashedpassword3",
				SessionID:    sql.NullString{String: "session456", Valid: true},
			},
			expectError: false,
			expectFound: true,
		},
		{
			name:        "should return nil for non-existing user",
			username:    "nonexistentuser",
			expectError: false,
			expectFound: false,
		},
	}

	for _, tt := range tests {
		suite.Run(tt.name, func() {
			var username string
			if tt.setupUser != nil {
				// Create user first
				err := suite.dao.CreateUser(tt.setupUser)
				require.NoError(suite.T(), err, "Failed to create user for test")
				username = tt.setupUser.Username
			} else {
				username = tt.username
			}

			// Test GetUserByUsername
			retrievedUser, err := suite.dao.GetUserByUsername(username)
			if tt.expectError {
				assert.Error(suite.T(), err, "Expected error but got none")
			} else {
				assert.NoError(suite.T(), err, "GetUserByUsername should not return error")
				if tt.expectFound {
					require.NotNil(suite.T(), retrievedUser, "User should be found")
					assert.Equal(suite.T(), username, retrievedUser.Username, "Username should match")
					if tt.setupUser != nil {
						assert.Equal(suite.T(), tt.setupUser.ID, retrievedUser.ID, "User ID should match")
					}
				} else {
					assert.Nil(suite.T(), retrievedUser, "User should not be found")
				}
			}
		})
	}
}

func (suite *DaoTestSuite) TestGetAnalysesByUserID() {
	tests := []struct {
		name              string
		userID            uuid.UUID
		analysesToCreate  int
		page              int
		limit             int
		expectedCount     int
		expectedTotal     int
		expectError       bool
	}{
		{
			name:              "should retrieve analyses for user with multiple analyses",
			userID:            uuid.New(),
			analysesToCreate:  3,
			page:              1,
			limit:             10,
			expectedCount:     3,
			expectedTotal:     3,
			expectError:       false,
		},
		{
			name:              "should handle pagination correctly",
			userID:            uuid.New(),
			analysesToCreate:  5,
			page:              1,
			limit:             2,
			expectedCount:     2,
			expectedTotal:     5,
			expectError:       false,
		},
		{
			name:              "should return empty result for user with no analyses",
			userID:            uuid.New(),
			analysesToCreate:  0,
			page:              1,
			limit:             10,
			expectedCount:     0,
			expectedTotal:     0,
			expectError:       false,
		},
	}

	for _, tt := range tests {
		suite.Run(tt.name, func() {
			// Create analyses for the user
			for i := 0; i < tt.analysesToCreate; i++ {
				analysis := &db.Analysis{
					ID:         uuid.New(),
					UserID:     tt.userID,
					Text:       fmt.Sprintf("This is analysis number %d for testing pagination and retrieval.", i),
					Title:      fmt.Sprintf("Analysis %d", i),
					Summary:    fmt.Sprintf("This is a summary for analysis %d.", i),
					Topics:     []string{"testing", "analysis", "pagination"},
					Sentiment:  "neutral",
					Keywords:   []string{"analysis", "test", "data"},
					Confidence: 0.8,
				}

				err := suite.dao.CreateAnalysis(analysis)
				require.NoError(suite.T(), err, "Failed to create analysis %d", i)
			}

			// Test GetAnalysesByUserID
			analyses, total, err := suite.dao.GetAnalysesByUserID(tt.userID, tt.page, tt.limit)
			if tt.expectError {
				assert.Error(suite.T(), err, "Expected error but got none")
			} else {
				assert.NoError(suite.T(), err, "GetAnalysesByUserID should not return error")
				assert.Equal(suite.T(), tt.expectedCount, len(analyses), "Expected %d analyses, got %d", tt.expectedCount, len(analyses))
				assert.Equal(suite.T(), tt.expectedTotal, total, "Expected total %d, got %d", tt.expectedTotal, total)
			}
		})
	}
}

func (suite *DaoTestSuite) TestUpdateAnalysis() {
	tests := []struct {
		name        string
		setupAnalysis *db.Analysis
		updates     *db.Analysis
		expectError bool
	}{
		{
			name: "should update analysis successfully",
			setupAnalysis: &db.Analysis{
				ID:         uuid.New(),
				UserID:     uuid.New(),
				Text:       "Original text for analysis.",
				Title:      "Original Title",
				Summary:    "Original summary.",
				Topics:     []string{"original", "topic", "analysis"},
				Sentiment:  "neutral",
				Keywords:   []string{"original", "keyword", "test"},
				Confidence: 0.7,
			},
			updates: &db.Analysis{
				Title:      "Updated Title",
				Summary:    "Updated summary with more detailed information.",
				Topics:     []string{"updated", "enhanced", "analysis"},
				Sentiment:  "positive",
				Keywords:   []string{"updated", "enhanced", "data"},
				Confidence: 0.9,
			},
			expectError: false,
		},
	}

	for _, tt := range tests {
		suite.Run(tt.name, func() {
			// Create analysis first
			err := suite.dao.CreateAnalysis(tt.setupAnalysis)
			require.NoError(suite.T(), err, "Failed to create analysis for test")

			// Update the analysis
			tt.setupAnalysis.Title = tt.updates.Title
			tt.setupAnalysis.Summary = tt.updates.Summary
			tt.setupAnalysis.Topics = tt.updates.Topics
			tt.setupAnalysis.Sentiment = tt.updates.Sentiment
			tt.setupAnalysis.Keywords = tt.updates.Keywords
			tt.setupAnalysis.Confidence = tt.updates.Confidence

			err = suite.dao.UpdateAnalysis(tt.setupAnalysis)
			if tt.expectError {
				assert.Error(suite.T(), err, "Expected error but got none")
			} else {
				assert.NoError(suite.T(), err, "UpdateAnalysis should not return error")

				// Verify analysis was updated
				updatedAnalysis, err := suite.dao.GetAnalysisByID(tt.setupAnalysis.ID)
				require.NoError(suite.T(), err, "GetAnalysisByID should not return error")
				require.NotNil(suite.T(), updatedAnalysis, "Analysis should be found")
				assert.Equal(suite.T(), tt.updates.Title, updatedAnalysis.Title, "Title should be updated")
				assert.Equal(suite.T(), tt.updates.Summary, updatedAnalysis.Summary, "Summary should be updated")
				assert.Equal(suite.T(), tt.updates.Topics, updatedAnalysis.Topics, "Topics should be updated")
				assert.Equal(suite.T(), tt.updates.Sentiment, updatedAnalysis.Sentiment, "Sentiment should be updated")
				assert.Equal(suite.T(), tt.updates.Keywords, updatedAnalysis.Keywords, "Keywords should be updated")
				assert.Equal(suite.T(), tt.updates.Confidence, updatedAnalysis.Confidence, "Confidence should be updated")
			}
		})
	}
}

func (suite *DaoTestSuite) TestDeleteAnalysis() {
	tests := []struct {
		name        string
		setupAnalysis *db.Analysis
		expectError bool
	}{
		{
			name: "should delete analysis successfully",
			setupAnalysis: &db.Analysis{
				ID:         uuid.New(),
				UserID:     uuid.New(),
				Text:       "This analysis will be deleted.",
				Title:      "To Be Deleted",
				Summary:    "This analysis is created for deletion testing.",
				Topics:     []string{"deletion", "testing", "analysis"},
				Sentiment:  "neutral",
				Keywords:   []string{"delete", "test", "analysis"},
				Confidence: 0.6,
			},
			expectError: false,
		},
	}

	for _, tt := range tests {
		suite.Run(tt.name, func() {
			// Create analysis first
			err := suite.dao.CreateAnalysis(tt.setupAnalysis)
			require.NoError(suite.T(), err, "Failed to create analysis for test")

			// Delete the analysis
			err = suite.dao.DeleteAnalysis(tt.setupAnalysis.ID)
			if tt.expectError {
				assert.Error(suite.T(), err, "Expected error but got none")
			} else {
				assert.NoError(suite.T(), err, "DeleteAnalysis should not return error")

				// Verify analysis was deleted
				deletedAnalysis, err := suite.dao.GetAnalysisByID(tt.setupAnalysis.ID)
				require.NoError(suite.T(), err, "GetAnalysisByID should not return error")
				assert.Nil(suite.T(), deletedAnalysis, "Analysis should not be found after deletion")
			}
		})
	}
}

func (suite *DaoTestSuite) TestSearchAnalyses() {
	tests := []struct {
		name              string
		userID            uuid.UUID
		analysesToCreate  []*db.Analysis
		topic             string
		keyword           string
		sentiment         string
		page              int
		limit             int
		expectedCount     int
		expectedTotal     int
		expectError       bool
	}{
		{
			name:   "should search analyses by topic",
			userID: uuid.New(),
			analysesToCreate: []*db.Analysis{
				{
					ID:         uuid.New(),
					UserID:     uuid.New(),
					Text:       "This is about artificial intelligence and machine learning.",
					Title:      "AI Article",
					Summary:    "Discussion about AI technologies.",
					Topics:     []string{"artificial intelligence", "technology", "future"},
					Sentiment:  "positive",
					Keywords:   []string{"intelligence", "learning", "technology"},
					Confidence: 0.9,
				},
				{
					ID:         uuid.New(),
					UserID:     uuid.New(),
					Text:       "This is about cooking and recipes.",
					Title:      "Cooking Guide",
					Summary:    "Guide to cooking techniques.",
					Topics:     []string{"cooking", "food", "recipes"},
					Sentiment:  "neutral",
					Keywords:   []string{"cooking", "food", "recipes"},
					Confidence: 0.8,
				},
			},
			topic:         "artificial intelligence",
			keyword:       "",
			sentiment:     "",
			page:          1,
			limit:         10,
			expectedCount: 1,
			expectedTotal: 1,
			expectError:   false,
		},
		{
			name:   "should search analyses by sentiment",
			userID: uuid.New(),
			analysesToCreate: []*db.Analysis{
				{
					ID:         uuid.New(),
					UserID:     uuid.New(),
					Text:       "This is a positive review of the product.",
					Title:      "Positive Review",
					Summary:    "Great product with excellent features.",
					Topics:     []string{"review", "product", "quality"},
					Sentiment:  "positive",
					Keywords:   []string{"review", "product", "quality"},
					Confidence: 0.85,
				},
				{
					ID:         uuid.New(),
					UserID:     uuid.New(),
					Text:       "This is a negative review of the service.",
					Title:      "Negative Review",
					Summary:    "Poor service with many issues.",
					Topics:     []string{"review", "service", "issues"},
					Sentiment:  "negative",
					Keywords:   []string{"review", "service", "issues"},
					Confidence: 0.75,
				},
			},
			topic:         "",
			keyword:       "",
			sentiment:     "positive",
			page:          1,
			limit:         10,
			expectedCount: 1,
			expectedTotal: 1,
			expectError:   false,
		},
	}

	for _, tt := range tests {
		suite.Run(tt.name, func() {
			// Create analyses for the test
			for _, analysis := range tt.analysesToCreate {
				analysis.UserID = tt.userID
				err := suite.dao.CreateAnalysis(analysis)
				require.NoError(suite.T(), err, "Failed to create analysis for test")
			}

			// Test SearchAnalyses
			analyses, total, err := suite.dao.SearchAnalyses(tt.topic, tt.keyword, tt.sentiment, tt.page, tt.limit)
			if tt.expectError {
				assert.Error(suite.T(), err, "Expected error but got none")
			} else {
				assert.NoError(suite.T(), err, "SearchAnalyses should not return error")
				assert.Equal(suite.T(), tt.expectedCount, len(analyses), "Expected %d analyses, got %d", tt.expectedCount, len(analyses))
				assert.Equal(suite.T(), tt.expectedTotal, total, "Expected total %d, got %d", tt.expectedTotal, total)
			}
		})
	}
}

func TestDaoTestSuite(t *testing.T) {
	suite.Run(t, new(DaoTestSuite))
}
